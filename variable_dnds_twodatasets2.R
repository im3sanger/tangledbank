# Variation in dN/dS across genes accounting for global differences in dN/dS in cancer genes.
# dnds1 and dnds2 are dndsout objects generated by running dndscv on a list of known cancer genes in two datasets.

# Subfunction. Comparing dN/dS values between two datasets using the uniform model and removing global differences in dN/dS between two datasets

variable_dNdS_twodatasets2 = function(dnds1, dnds2, genestotest) {
    
    library("seqinr")
    library("Biostrings")
    library("MASS")
    library("GenomicRanges")
    library("dndscv")
    
    pvec = rmisvec = rtruvec = rep(NA, length(genestotest)) # Initialising vectors for p-values and for the ratios of wmis and wtru between dataset 1 and 2
    w1 = dnds1$globaldnds$mle; names(w1) = dnds1$globaldnds$name
    w2 = dnds2$globaldnds$mle; names(w2) = dnds2$globaldnds$name
    
    for (g in 1:length(genestotest)) {
        
        # We can implement a simple LRT model based on the uniform dNdS model
        # This is different from the Fisher test in that it uses synonymous mutations (i.e. dN/dS ratios)
        # instead of comparing the contribution of nonsyn muts of a gene *relative* to other genes.
        # Being a uniform model it assumes no considerable changes in the mutation rate variation or coverage
        # across genes in both datasets. But takes into account signature and rate variation between two
        # datasets.
        # H0: wmis1==wmis2 & wtru1==wtru2
        # H1: wmis1!=wmis2 & wtru1!=wtru2
        # This is simply done using obs1, exp1, obs2, exp2 (y1 and y2 vectors below)
        
        y1 = as.numeric(dnds1$genemuts[dnds1$genemuts$gene==genestotest[g],])
        y2 = as.numeric(dnds2$genemuts[dnds2$genemuts$gene==genestotest[g],])
        
        # Global dN/dS ratios from all other genes (to normalise the differences for the gene being tested)        
        ind1 = dnds1$genemuts$gene!=genestotest[g]
        ind2 = dnds2$genemuts$gene!=genestotest[g]
        wmis1_global = sum(dnds1$genemuts$n_mis[ind1])/sum(dnds1$genemuts$exp_mis[ind1])
        wmis2_global = sum(dnds2$genemuts$n_mis[ind2])/sum(dnds2$genemuts$exp_mis[ind2])
        wtru1_global = sum(dnds1$genemuts$n_non[ind1]+dnds1$genemuts$n_spl[ind1])/sum(dnds1$genemuts$exp_non[ind1]+dnds1$genemuts$exp_spl[ind1])
        wtru2_global = sum(dnds2$genemuts$n_non[ind2]+dnds2$genemuts$n_spl[ind2])/sum(dnds2$genemuts$exp_non[ind2]+dnds2$genemuts$exp_spl[ind2])
        
        # MLE dN/dS ratios using the uniform model under H0 and H1
        wmis_mle0 = (y1[3]+y2[3])/(y1[7]*wmis1_global+y2[7]*wmis2_global)
        wtru_mle0 = sum(y1[4:5]+y2[4:5])/sum(y1[8:9]*wtru1_global+y2[8:9]*wtru2_global)
        wmis_mle1 = c(y1[3],y2[3])/c(y1[7]*wmis1_global,y2[7]*wmis2_global)
        wtru_mle1 = c(sum(y1[4:5]),sum(y2[4:5]))/c(sum(y1[8:9]*wtru1_global),sum(y2[8:9]*wtru2_global))
        
        # Observed and predicted counts under H0 and H1
        obs = as.numeric(c(y1[3], sum(y1[4:5]), y2[3], sum(y2[4:5])))
        exp0 = as.numeric(c(y1[7]*wmis1_global*wmis_mle0, sum(y1[8:9])*wtru1_global*wtru_mle0, y2[7]*wmis2_global*wmis_mle0, sum(y2[8:9])*wtru2_global*wtru_mle0))
        exp1 = as.numeric(c(y1[7]*wmis1_global*wmis_mle1[1], sum(y1[8:9])*wtru1_global*wtru_mle1[1], y2[7]*wmis2_global*wmis_mle1[2], sum(y2[8:9])*wtru2_global*wtru_mle1[2])) # Note that exp1 == obs (we only have this line here for confirmation purposes)
        ll0 = c(sum(dpois(x=obs[c(1,3)], lambda=exp0[c(1,3)], log=T)), sum(dpois(x=obs[c(2,4)], lambda=exp0[c(2,4)], log=T)))
        ll1 = c(sum(dpois(x=obs[c(1,3)], lambda=exp1[c(1,3)], log=T)), sum(dpois(x=obs[c(2,4)], lambda=exp1[c(2,4)], log=T)))
        
        # One-sided p-values
        pvals = (1-pchisq(2*(ll1-ll0), df=1))
        if (wmis_mle1[1]<wmis_mle1[2]) { pvals[1] = 1 } else { pvals[1] = pvals[1]/2 }
        if (wtru_mle1[1]<wtru_mle1[2]) { pvals[2] = 1 } else { pvals[2] = pvals[2]/2 }
        
        # Saving the results
        pvec[g] = 1 - pchisq(-2 * sum(log(pvals)), df = 4) # Fisher combined p-value
        rmisvec[g] = wmis_mle1[1]/wmis_mle1[2]
        rtruvec[g] = wtru_mle1[1]/wtru_mle1[2]
        
    }
    out = data.frame(genestotest,pvec,rmisvec,rtruvec)
    return(out)
}
